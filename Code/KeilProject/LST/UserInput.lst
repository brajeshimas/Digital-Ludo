C51 COMPILER V9.60.0.0   USERINPUT                                                         10/30/2023 23:23:23 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE USERINPUT
OBJECT MODULE PLACED IN .\OBJ\UserInput.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\UserCode\UserInput.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\HardWareCode;.
                    -.\HardWareCode;..\UserCode) DEBUG OBJECTEXTEND PRINT(.\LST\UserInput.lst) TABS(2) OBJECT(.\OBJ\UserInput.obj)

line level    source

   1          
   2          #include <REG_MG82F6D17.h>
   3          #include ".\include\Type.h"
   4          #include ".\include\API_Macro_MG82F6D17.H"
   5          
   6          #include "UserInput.h"
   7          #include "SPI.h"
   8          #include "HardWare.h"
   9          #include "Delay.h"
  10          #include "LedBoard.h"
  11          #include "Buzzer.h"
  12          #include "User.h"
  13          #include "UserDriverBridge.h"
  14          
  15          #define KEYDEBOUNCE_TIME          100  //millli second
  16          #define KEYLONGPRESSS_TIME        1500 //milli second
  17          #define KEY_RAMP_TIME             5//milli second
  18          
  19          #define ROWKEY1_PIN      P10    
  20          #define ROWKEY2_PIN      P11
  21          #define ROWKEY3_PIN      P15
  22          #define ROWKEY4_PIN      P16
  23          
  24          #define KEY_COLM1_PIN        P61
  25          #define KEY_COLM2_PIN        P60
  26          #define KEY_COLM3_PIN        P24
  27          #define KEY_COLM4_PIN        P22
  28          
  29          
  30          
  31          
  32          #define INPUT_INIT           0
  33          #define INPUT_IDLE           1
  34          #define INPUT_CHECK          2
  35          #define INPUT_DEBOUNCE       3
  36          #define INPUT_LONG_PRESSED   4
  37          
  38          
  39          
  40          #define KEY_VS_TOKN_INIT                0
  41          #define KEY_VS_TOKN_IDLE                1
  42          #define KEY_TOKN_BLINK                  2
  43          #define KEY_TOKN_BLINK_OFF              3
  44          #define KEY_TOKN_BLINK_ON               4
  45          #define KEY_TOKN_BLINK_STOP             5
  46          
  47          #define KEY_TOKN_BLINK_TIME         80//MILLI SECOND
  48          uint8_t BlinkTokn;
  49          uint8_t TokenNmbr;
  50          uint8_t ToknColour;
  51          uint8_t BlinkCounter;
  52          uint8_t KeyToknBlinkTimer;
  53          uint8_t keyvsToknState;
  54          
C51 COMPILER V9.60.0.0   USERINPUT                                                         10/30/2023 23:23:23 PAGE 2   

  55          
  56          
  57          uint8_t InputState;
  58          uint8_t KeyPressedRowValue;
  59          uint8_t KeyColmValue;
  60          uint8_t PreColmValue;
  61          uint8_t LongPressedCounter;
  62          uint8_t UserInput;
  63          uint8_t ToknCheckInput;
  64          uint32_t KeyPressedTimer;
  65          bit KeyPressedFlg;
  66          bit CheckToknFlg = 0;
  67          bit KeyPressedOkFlg = 0;
  68          //uint8_t GetKeyPressed(void);
  69          void DeactivateColm(uint8_t KeyColmNumber);
  70          void ActivateColm(uint8_t KeyColmNumber);
  71          
  72          
  73          
  74          
  75          
  76          
  77          void ScanInput(void)
  78          {
  79   1        switch(InputState)
  80   1        {
  81   2          case INPUT_INIT:
  82   2            UserInput = 0;
  83   2            ToknCheckInput = 0;
  84   2            KeyColmValue = 12;
  85   2            InputState = INPUT_IDLE;
  86   2            break;
  87   2          
  88   2          case INPUT_IDLE:
  89   2            KeyColmValue++;
  90   2            ActivateColm(KeyColmValue);
  91   2            DeactivateColm(KeyColmValue-1);
  92   2            if(KeyColmValue == 17)
  93   2            {
  94   3              KeyColmValue = 12;
  95   3            }
  96   2            else
  97   2            {
  98   3            KeyPressedTimer = KEY_RAMP_TIME;
  99   3            InputState = INPUT_CHECK;
 100   3            }
 101   2            break;
 102   2          
 103   2          case INPUT_CHECK:
 104   2            if(KeyPressedTimer == 0)
 105   2            {
 106   3              KeyPressedRowValue = 0;
 107   3              
 108   3              KeyPressedRowValue = GetKeyPressed();
 109   3              if(KeyPressedRowValue > 0)
 110   3              {
 111   4                PreColmValue = KeyColmValue;
 112   4                KeyPressedTimer = KEYDEBOUNCE_TIME;
 113   4                InputState = INPUT_DEBOUNCE;
 114   4              }
 115   3              else
 116   3              {InputState = INPUT_IDLE;}        
C51 COMPILER V9.60.0.0   USERINPUT                                                         10/30/2023 23:23:23 PAGE 3   

 117   3            }
 118   2            break;
 119   2            
 120   2        
 121   2         case INPUT_DEBOUNCE:
 122   2           if(KeyPressedTimer == 0)
 123   2           {
 124   3             if(GetKeyPressed() == KeyPressedRowValue)
 125   3             {
 126   4              SetBeepIndication(SHORT_BEEP,1);
 127   4              KeyPressedTimer = KEYLONGPRESSS_TIME;
 128   4              InputState = INPUT_LONG_PRESSED;
 129   4              KeyPressedFlg = 1;LongPressedCounter = 0;
 130   4              ToknCheckInput = KeyColmValue*KeyPressedRowValue;
 131   4             }
 132   3             else
 133   3             {InputState = INPUT_IDLE;}
 134   3           }
 135   2           break;
 136   2            
 137   2         case INPUT_LONG_PRESSED:
 138   2            if(KeyPressedTimer == 0)
 139   2            {       
 140   3                 if((GetKeyPressed() == KeyPressedRowValue))
 141   3                 {
 142   4                   KeyPressedTimer = 3000;
 143   4                   LongPressedCounter++;
 144   4                   SetBeepIndication(SHORT_BEEP,1);
 145   4                   /*if(LongPressedCounter > 2)
 146   4                   {
 147   4                    LongPressedCounter = 0;
 148   4                    LongKeyFlg = 1;
 149   4                    ToknCheckInput = KeyColmValue*KeyPressedRowValue;
 150   4                   }*/
 151   4                   
 152   4                 }  
 153   3                else
 154   3                {
 155   4                 KeyPressedFlg = 0;
 156   4                 if(LongPressedCounter>0)
 157   4                 UserInput = 0; 
 158   4                 else
 159   4                 UserInput = KeyColmValue*KeyPressedRowValue;
 160   4                 InputState = INPUT_IDLE;
 161   4                }   
 162   3      
 163   3            }
 164   2            break;
 165   2          
 166   2        }
 167   1      }
 168          
 169          
 170          void ActivateColm(uint8_t KeyColmNumber)
 171          {
 172   1        switch(KeyColmNumber)
 173   1        {
 174   2          case 13:KEY_COLM1_PIN = 1;break;
 175   2          case 14:KEY_COLM2_PIN = 1;break;
 176   2          case 15:KEY_COLM3_PIN = 1;break;
 177   2          case 16:KEY_COLM4_PIN = 1;break;
 178   2        }
C51 COMPILER V9.60.0.0   USERINPUT                                                         10/30/2023 23:23:23 PAGE 4   

 179   1        
 180   1      }
 181          
 182          void DeactivateColm(uint8_t KeyColmNumber)
 183          {
 184   1        switch(KeyColmNumber)
 185   1        {
 186   2          case 13:KEY_COLM1_PIN = 0;break;
 187   2          case 14:KEY_COLM2_PIN = 0;break;
 188   2          case 15:KEY_COLM3_PIN = 0;break;
 189   2          case 16:KEY_COLM4_PIN = 0;break;
 190   2        }
 191   1        
 192   1      }
 193          
 194          
 195          uint8_t GetKeyPressed(void)
 196          {
 197   1      
 198   1        if(ROWKEY1_PIN)
 199   1        return 1;
 200   1        else if(ROWKEY2_PIN)
 201   1        return 2;
 202   1        else if(ROWKEY3_PIN)
 203   1        return 3;
 204   1        else if(ROWKEY4_PIN)
 205   1        return 4;
 206   1        else 
 207   1        return 0;
 208   1          
 209   1      }
 210          
 211          void InputScanTimer(void)
 212          {
 213   1        if(KeyPressedTimer>0)
 214   1          KeyPressedTimer--;
 215   1      }
 216          
 217          
 218          
 219          /*
 220          void CheckKeyVsTokn(void)
 221          {
 222            switch(keyvsToknState)
 223            {
 224              case KEY_VS_TOKN_INIT:
 225                BlinkCounter = 0;
 226                keyvsToknState = KEY_VS_TOKN_IDLE;
 227                break;
 228              
 229              case KEY_VS_TOKN_IDLE:
 230                if(LongKeyFlg)
 231                {
 232                  if(ToknCheckInput>0)
 233                  keyvsToknState = ToknCheckInput;ToknCheckInput = 0;
 234                }
 235                break;
 236              case RED_KEY1:BlinkTokn = Red[0];TokenNmbr = 0;ToknColour = RED;keyvsToknState = KEY_TOKN_BLINK;break;
 237              case RED_KEY2:BlinkTokn = Red[1];TokenNmbr = 1;ToknColour = RED;keyvsToknState = KEY_TOKN_BLINK;break;
 238              case RED_KEY3:BlinkTokn = Red[2];TokenNmbr = 2;ToknColour = RED;keyvsToknState = KEY_TOKN_BLINK;break;
 239              case RED_KEY4:BlinkTokn = Red[3];TokenNmbr = 3;ToknColour = RED;keyvsToknState = KEY_TOKN_BLINK;break;
 240                
C51 COMPILER V9.60.0.0   USERINPUT                                                         10/30/2023 23:23:23 PAGE 5   

 241              case BLUE_KEY1:BlinkTokn = Blue[0];TokenNmbr = 0;ToknColour = BLUE;keyvsToknState = KEY_TOKN_BLINK;break
             -;
 242              case BLUE_KEY2:BlinkTokn = Blue[1];TokenNmbr = 1;ToknColour = BLUE;keyvsToknState = KEY_TOKN_BLINK;break
             -;
 243              case BLUE_KEY3:BlinkTokn = Blue[2];TokenNmbr = 2;ToknColour = BLUE;keyvsToknState = KEY_TOKN_BLINK;break
             -;
 244              case BLUE_KEY4:BlinkTokn = Blue[3];TokenNmbr = 3;ToknColour = BLUE;keyvsToknState = KEY_TOKN_BLINK;break
             -;
 245                
 246              case GREEN_KEY1:BlinkTokn = Green[0];TokenNmbr = 0;ToknColour = GREEN;keyvsToknState = KEY_TOKN_BLINK;br
             -eak;
 247              case GREEN_KEY2:BlinkTokn = Green[1];TokenNmbr = 1;ToknColour = GREEN;keyvsToknState = KEY_TOKN_BLINK;br
             -eak;
 248              case GREEN_KEY3:BlinkTokn = Green[2];TokenNmbr = 2;ToknColour = GREEN;keyvsToknState = KEY_TOKN_BLINK;br
             -eak;
 249              case GREEN_KEY4:BlinkTokn = Green[3];TokenNmbr = 3;ToknColour = GREEN;keyvsToknState = KEY_TOKN_BLINK;br
             -eak;
 250                
 251              case YELLOW_KEY1:BlinkTokn = Yellow[0];TokenNmbr = 0;ToknColour = YELLOW;keyvsToknState = KEY_TOKN_BLINK
             -;break;
 252              case YELLOW_KEY2:BlinkTokn = Yellow[1];TokenNmbr = 1;ToknColour = YELLOW;keyvsToknState = KEY_TOKN_BLINK
             -;break;
 253              case YELLOW_KEY3:BlinkTokn = Yellow[2];TokenNmbr = 2;ToknColour = YELLOW;keyvsToknState = KEY_TOKN_BLINK
             -;break;
 254              case YELLOW_KEY4:BlinkTokn = Yellow[3];TokenNmbr = 3;ToknColour = YELLOW;keyvsToknState = KEY_TOKN_BLINK
             -;break;
 255                
 256              case KEY_TOKN_BLINK:
 257                DcodeToknToLedNumber(TokenNmbr,58,ToknColour);
 258                KeyToknBlinkTimer = KEY_TOKN_BLINK_TIME;
 259                keyvsToknState = KEY_TOKN_BLINK_OFF;
 260                BlinkCounter = 0;
 261                break;
 262              
 263              case KEY_TOKN_BLINK_OFF:
 264                if(KeyToknBlinkTimer == 0)
 265                {
 266                  DcodeToknToLedNumber(TokenNmbr,BlinkTokn,ToknColour);
 267                  KeyToknBlinkTimer = KEY_TOKN_BLINK_TIME;
 268                  keyvsToknState = KEY_TOKN_BLINK_ON;
 269                }
 270              break;
 271                
 272              case KEY_TOKN_BLINK_ON:
 273                if(KeyToknBlinkTimer == 0)
 274                {
 275                  DcodeToknToLedNumber(TokenNmbr,58,ToknColour);
 276                  KeyToknBlinkTimer = KEY_TOKN_BLINK_TIME;
 277                  keyvsToknState = KEY_TOKN_BLINK_OFF;
 278                  BlinkCounter++;
 279                  if(BlinkCounter == 10)
 280                  {
 281                    BlinkCounter = 0;
 282                    DcodeToknToLedNumber(TokenNmbr,BlinkTokn,ToknColour);
 283                    keyvsToknState = KEY_VS_TOKN_IDLE;
 284                  }
 285                }
 286              break;
 287                  
 288                
 289            }
 290          }
C51 COMPILER V9.60.0.0   USERINPUT                                                         10/30/2023 23:23:23 PAGE 6   

 291          */
 292          
 293          
 294          
 295          
 296          
 297          
 298          
 299          
 300          
 301          void CheckKeyVsTokn(void)
 302          {
 303   1        switch(keyvsToknState)
 304   1        {
 305   2          case KEY_VS_TOKN_INIT:
 306   2            BlinkCounter = 0;
 307   2            keyvsToknState = KEY_VS_TOKN_IDLE;
 308   2            break;
 309   2          
 310   2          case KEY_VS_TOKN_IDLE:
 311   2            if((CheckToknFlg == 1)&&(KeyPressedFlg == 1))
 312   2            {
 313   3              if(ToknCheckInput>0)
 314   3              keyvsToknState = ToknCheckInput;ToknCheckInput = 0;
 315   3            }
 316   2            break;
 317   2          case RED_KEY1:BlinkTokn = Red[0];TokenNmbr = 0;ToknColour = RED;keyvsToknState = KEY_TOKN_BLINK;break;
 318   2          case RED_KEY2:BlinkTokn = Red[1];TokenNmbr = 1;ToknColour = RED;keyvsToknState = KEY_TOKN_BLINK;break;
 319   2          case RED_KEY3:BlinkTokn = Red[2];TokenNmbr = 2;ToknColour = RED;keyvsToknState = KEY_TOKN_BLINK;break;
 320   2          case RED_KEY4:BlinkTokn = Red[3];TokenNmbr = 3;ToknColour = RED;keyvsToknState = KEY_TOKN_BLINK;break;
 321   2            
 322   2          case BLUE_KEY1:BlinkTokn = Blue[0];TokenNmbr = 0;ToknColour = BLUE;keyvsToknState = KEY_TOKN_BLINK;break
             -;
 323   2          case BLUE_KEY2:BlinkTokn = Blue[1];TokenNmbr = 1;ToknColour = BLUE;keyvsToknState = KEY_TOKN_BLINK;break
             -;
 324   2          case BLUE_KEY3:BlinkTokn = Blue[2];TokenNmbr = 2;ToknColour = BLUE;keyvsToknState = KEY_TOKN_BLINK;break
             -;
 325   2          case BLUE_KEY4:BlinkTokn = Blue[3];TokenNmbr = 3;ToknColour = BLUE;keyvsToknState = KEY_TOKN_BLINK;break
             -;
 326   2            
 327   2          case GREEN_KEY1:BlinkTokn = Green[0];TokenNmbr = 0;ToknColour = GREEN;keyvsToknState = KEY_TOKN_BLINK;br
             -eak;
 328   2          case GREEN_KEY2:BlinkTokn = Green[1];TokenNmbr = 1;ToknColour = GREEN;keyvsToknState = KEY_TOKN_BLINK;br
             -eak;
 329   2          case GREEN_KEY3:BlinkTokn = Green[2];TokenNmbr = 2;ToknColour = GREEN;keyvsToknState = KEY_TOKN_BLINK;br
             -eak;
 330   2          case GREEN_KEY4:BlinkTokn = Green[3];TokenNmbr = 3;ToknColour = GREEN;keyvsToknState = KEY_TOKN_BLINK;br
             -eak;
 331   2            
 332   2          case YELLOW_KEY1:BlinkTokn = Yellow[0];TokenNmbr = 0;ToknColour = YELLOW;keyvsToknState = KEY_TOKN_BLINK
             -;break;
 333   2          case YELLOW_KEY2:BlinkTokn = Yellow[1];TokenNmbr = 1;ToknColour = YELLOW;keyvsToknState = KEY_TOKN_BLINK
             -;break;
 334   2          case YELLOW_KEY3:BlinkTokn = Yellow[2];TokenNmbr = 2;ToknColour = YELLOW;keyvsToknState = KEY_TOKN_BLINK
             -;break;
 335   2          case YELLOW_KEY4:BlinkTokn = Yellow[3];TokenNmbr = 3;ToknColour = YELLOW;keyvsToknState = KEY_TOKN_BLINK
             -;break;
 336   2            
 337   2          case KEY_TOKN_BLINK:
 338   2            if(KeyPressedFlg)
 339   2            {
 340   3              DcodeToknToLedNumber(TokenNmbr,58,ToknColour);
C51 COMPILER V9.60.0.0   USERINPUT                                                         10/30/2023 23:23:23 PAGE 7   

 341   3              KeyToknBlinkTimer = KEY_TOKN_BLINK_TIME;
 342   3              keyvsToknState = KEY_TOKN_BLINK_OFF;
 343   3              BlinkCounter = 0;
 344   3            }
 345   2            else
 346   2            {
 347   3              keyvsToknState = KEY_VS_TOKN_IDLE;
 348   3            }
 349   2            break;
 350   2          
 351   2          case KEY_TOKN_BLINK_OFF:
 352   2            if(KeyToknBlinkTimer == 0)
 353   2            {
 354   3              DcodeToknToLedNumber(TokenNmbr,BlinkTokn,ToknColour);
 355   3              KeyToknBlinkTimer = KEY_TOKN_BLINK_TIME;
 356   3              keyvsToknState = KEY_TOKN_BLINK_ON;
 357   3            }
 358   2            
 359   2            if(KeyPressedFlg == 0)
 360   2            {
 361   3             if(LongPressedCounter==0)KeyPressedOkFlg = 1;
 362   3             DcodeToknToLedNumber(TokenNmbr,BlinkTokn,ToknColour);keyvsToknState = KEY_VS_TOKN_IDLE;
 363   3            }
 364   2            
 365   2            else if(LongPressedCounter>0)
 366   2            {DcodeToknToLedNumber(TokenNmbr,BlinkTokn,ToknColour);keyvsToknState = KEY_TOKN_BLINK_STOP;}
 367   2          break;
 368   2            
 369   2          case KEY_TOKN_BLINK_ON:
 370   2            if(KeyToknBlinkTimer == 0)
 371   2            {
 372   3              DcodeToknToLedNumber(TokenNmbr,58,ToknColour);
 373   3              KeyToknBlinkTimer = KEY_TOKN_BLINK_TIME;
 374   3              keyvsToknState = KEY_TOKN_BLINK_OFF;
 375   3              BlinkCounter++;
 376   3              /*if(BlinkCounter == 10)
 377   3              {
 378   3                BlinkCounter = 0;
 379   3                DcodeToknToLedNumber(TokenNmbr,BlinkTokn,ToknColour);
 380   3                keyvsToknState = KEY_VS_TOKN_IDLE;
 381   3              }*/
 382   3            }
 383   2            if(KeyPressedFlg == 0)
 384   2            {
 385   3             if(LongPressedCounter==0)KeyPressedOkFlg = 1;
 386   3             DcodeToknToLedNumber(TokenNmbr,BlinkTokn,ToknColour);keyvsToknState = KEY_VS_TOKN_IDLE;
 387   3            }
 388   2            
 389   2            else if(LongPressedCounter>0)
 390   2            {DcodeToknToLedNumber(TokenNmbr,BlinkTokn,ToknColour);keyvsToknState = KEY_TOKN_BLINK_STOP;}
 391   2          break;
 392   2          
 393   2          case KEY_TOKN_BLINK_STOP:
 394   2            if(KeyPressedFlg == 0)
 395   2            {
 396   3              keyvsToknState = KEY_VS_TOKN_IDLE;
 397   3            }
 398   2            break;
 399   2              
 400   2            
 401   2        }
 402   1      }
C51 COMPILER V9.60.0.0   USERINPUT                                                         10/30/2023 23:23:23 PAGE 8   

 403          
 404          
 405          void ToknBlinkTimer(void)
 406          {
 407   1        if(KeyToknBlinkTimer>0)
 408   1          KeyToknBlinkTimer--;
 409   1      }
 410          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    862    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     17    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
