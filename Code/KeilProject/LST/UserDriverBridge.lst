C51 COMPILER V9.60.0.0   USERDRIVERBRIDGE                                                  10/30/2023 23:23:23 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE USERDRIVERBRIDGE
OBJECT MODULE PLACED IN .\OBJ\UserDriverBridge.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\UserCode\UserDriverBridge.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\HardWar
                    -eCode;..\HardWareCode;..\UserCode) DEBUG OBJECTEXTEND PRINT(.\LST\UserDriverBridge.lst) TABS(2) OBJECT(.\OBJ\UserDriverB
                    -ridge.obj)

line level    source

   1          
   2          
   3          #include <REG_MG82F6D17.h>
   4          #include ".\include\Type.h"
   5          #include ".\include\API_Macro_MG82F6D17.H"
   6          
   7          #include "UserDriverBridge.h"
   8          #include "USER.h"
   9          #include "LedBoard.h"
  10          
  11          
  12          #define DECODE_INIT      0
  13          #define DECODE_RED       1
  14          #define DECODE_BLUE      2
  15          #define DECODE_GREEN     3
  16          #define DECODE_YELLOW    4
  17          #define DECODE_NEXT      5
  18          
  19          
  20          
  21          
  22          
  23           uint8_t DcodedRed[4];
  24           uint8_t DcodedBlue[4];
  25           uint8_t DcodedGreen[4];
  26           uint8_t DcodedYellow[4];
  27          
  28          uint8_t DecodeState;
  29          uint8_t ToknNmbr = 0;
  30          
  31          uint8_t PreRed[4]    = {0,0,0,0};
  32          uint8_t PreBlue[4]   = {0,0,0,0};
  33          uint8_t PreGreen[4]  = {0,0,0,0};
  34          uint8_t PreYellow[4] = {0,0,0,0};
  35          
  36          //void DcodeToknToLedNumber(uint8_t TokenNumber,uint8_t TokenValue,uint8_t ToknColour);
  37          void DecodeManager(void)
  38          {
  39   1        switch(DecodeState)
  40   1        {
  41   2          case DECODE_INIT:
  42   2          for(ToknNmbr = 0;ToknNmbr<4;ToknNmbr++)
  43   2          {
  44   3            DcodeToknToLedNumber(ToknNmbr,Red[ToknNmbr],RED);
  45   3            DcodeToknToLedNumber(ToknNmbr,Blue[ToknNmbr],BLUE);
  46   3            DcodeToknToLedNumber(ToknNmbr,Green[ToknNmbr],GREEN);
  47   3            DcodeToknToLedNumber(ToknNmbr,Yellow[ToknNmbr],YELLOW);
  48   3          } 
  49   2          ToknNmbr = 0;
  50   2          DecodeState = DECODE_RED;
  51   2          break;
  52   2          
  53   2          case DECODE_RED:
C51 COMPILER V9.60.0.0   USERDRIVERBRIDGE                                                  10/30/2023 23:23:23 PAGE 2   

  54   2          if(PreRed[ToknNmbr] != Red[ToknNmbr])
  55   2          {PreRed[ToknNmbr] = Red[ToknNmbr];DcodeToknToLedNumber(ToknNmbr,Red[ToknNmbr],RED);}
  56   2          DecodeState = DECODE_BLUE;
  57   2          break;
  58   2      
  59   2          case DECODE_BLUE:
  60   2          if(PreBlue[ToknNmbr] != Blue[ToknNmbr])
  61   2          {PreBlue[ToknNmbr] = Blue[ToknNmbr];DcodeToknToLedNumber(ToknNmbr,Blue[ToknNmbr],BLUE);}
  62   2          DecodeState = DECODE_GREEN;
  63   2          break;
  64   2      
  65   2          case DECODE_GREEN:
  66   2          if(PreGreen[ToknNmbr] != Green[ToknNmbr])
  67   2          {PreGreen[ToknNmbr] = Green[ToknNmbr];DcodeToknToLedNumber(ToknNmbr,Green[ToknNmbr],GREEN);}
  68   2          DecodeState = DECODE_YELLOW;
  69   2          break;
  70   2      
  71   2          case DECODE_YELLOW:
  72   2          if(PreYellow[ToknNmbr] != Yellow[ToknNmbr])
  73   2          {PreYellow[ToknNmbr] = Yellow[ToknNmbr];DcodeToknToLedNumber(ToknNmbr,Yellow[ToknNmbr],YELLOW);}
  74   2          DecodeState = DECODE_NEXT;
  75   2          break;
  76   2      
  77   2          case DECODE_NEXT:
  78   2          ToknNmbr++;
  79   2          if(ToknNmbr == 4)ToknNmbr = 0;
  80   2          DecodeState = DECODE_RED;
  81   2          break;
  82   2          
  83   2        }
  84   1      }
  85          void DcodeToknToLedNumber(uint8_t TokenNumber,uint8_t TokenValue,uint8_t ToknColour)
  86          {
  87   1        switch(ToknColour)
  88   1        {
  89   2          case RED:
  90   2          if(TokenValue == 0)
  91   2          {DcodedRed[TokenNumber] = RH1+TokenNumber;}
  92   2          else if(TokenValue < 57)
  93   2          {DcodedRed[TokenNumber] = TokenValue;}
  94   2          else if(TokenValue > 56 )
  95   2          {DcodedRed[TokenNumber] = TOKEN_OUT_R1 + TokenNumber;}
  96   2          break;
  97   2      
  98   2      
  99   2          case BLUE:
 100   2          if(TokenValue == 0)
 101   2          {DcodedBlue[TokenNumber] = BH1+TokenNumber;}
 102   2          
 103   2          else if((TokenValue+13)<= 51)
 104   2          {DcodedBlue[TokenNumber] = TokenValue+13;}
 105   2          
 106   2          else if(((TokenValue+13)> 51)&& ((TokenValue+13) < 65))
 107   2          {DcodedBlue[TokenNumber] = (TokenValue+13)-52;}
 108   2      
 109   2          else if(((TokenValue+13)> 64)&& ((TokenValue+13) < 70))
 110   2          {DcodedBlue[TokenNumber] = (TokenValue+13)-8;}
 111   2          
 112   2          else if((TokenValue+13) > 69 )
 113   2          {DcodedBlue[TokenNumber] = TOKEN_OUT_B1 + TokenNumber;}
 114   2          break;
 115   2      
C51 COMPILER V9.60.0.0   USERDRIVERBRIDGE                                                  10/30/2023 23:23:23 PAGE 3   

 116   2          case GREEN:
 117   2          if(TokenValue == 0)
 118   2          {DcodedGreen[TokenNumber] = GH1+TokenNumber;}
 119   2          
 120   2          else if((TokenValue+26)<= 51)
 121   2          {DcodedGreen[TokenNumber] = TokenValue+26;}
 122   2          
 123   2          else if(((TokenValue+26)> 51)&& ((TokenValue+26) < 78))
 124   2          {DcodedGreen[TokenNumber] = (TokenValue+26)-52;}
 125   2      
 126   2          else if(((TokenValue+26)> 77)&& ((TokenValue+26) < 83))
 127   2          {DcodedGreen[TokenNumber] = (TokenValue+26)-16;}
 128   2          
 129   2          else if((TokenValue+26) > 82 )
 130   2          {DcodedGreen[TokenNumber] = TOKEN_OUT_G1 + TokenNumber;}
 131   2          break;
 132   2      
 133   2      
 134   2          case YELLOW:
 135   2          if(TokenValue == 0)
 136   2          {DcodedYellow[TokenNumber] = YH1+TokenNumber;}
 137   2          
 138   2          else if((TokenValue+39)<= 51)
 139   2          {DcodedYellow[TokenNumber] = TokenValue+39;}
 140   2          
 141   2          else if(((TokenValue+39)> 51)&& ((TokenValue+39) < 91))
 142   2          {DcodedYellow[TokenNumber] = (TokenValue+39)-52;}
 143   2      
 144   2          else if(((TokenValue+39)> 90)&& ((TokenValue+39) < 96))
 145   2          {DcodedYellow[TokenNumber] = (TokenValue+39)-24;}
 146   2          
 147   2          else if((TokenValue+39) > 95 )
 148   2          {DcodedYellow[TokenNumber] = TOKEN_OUT_Y1 + TokenNumber;}
 149   2          break;
 150   2        }
 151   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    827    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     34    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
