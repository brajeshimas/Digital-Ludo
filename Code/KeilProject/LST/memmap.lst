C51 COMPILER V9.60.0.0   MEMMAP                                                            10/30/2023 23:23:22 PAGE 1   


C51 COMPILER V9.60.0.0, COMPILATION OF MODULE MEMMAP
OBJECT MODULE PLACED IN .\OBJ\memmap.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE ..\HardWareCode\memmap.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\UserCode;..\H
                    -ardWareCode;..\UserCode) DEBUG OBJECTEXTEND PRINT(.\LST\memmap.lst) TABS(2) OBJECT(.\OBJ\memmap.obj)

line level    source

   1          #include ".\include\REG_MG82F6D17.H"
   2          #include ".\include\Type.h"
   3          #include ".\include\API_Macro_MG82F6D17.H"
   4          
   5          #include "memmap.h"
   6          #include "eeprom.h"
   7          #include "USER.h"
   8          
   9          
  10          /*
  11            Function Name : SetupMemMap()
  12            Called by     : Main.c
  13            Scope         : Public
  14            Description   : SetupMemMap() is called once by main() while booting the system.
  15                            It first checks the first byte of the Data Flash Memory which is located
  16                            at the last flash page having the start address as 0x3E00. If the first byte
  17                            is 0x01 then it does not make any changes to the Data Flash and exits after
  18                            clearing the Trapflags. But if the first byte is not 0x01 which means that 
  19                            Data Flash has not been initialized, then it clears the last Flash page and 
  20                            writes each setting byte one by one and then returns back after clearing 
  21                            the Trapflags.
  22                            
  23          */
  24          
  25          void SetupMemMap(void)
  26          {
  27   1         unsigned char EEPROM_Init_Flag;
  28   1         
  29   1         EEPROM_Init_Flag = EEPROM_Read_Byte((unsigned int) MEMMAP_EEPROM_INIT_FLAG);
  30   1                                                  
  31   1        
  32   1         if (EEPROM_Init_Flag!=EEPROM_INITIALIZED)
  33   1         {  
  34   2               
  35   2          IAP_ErasePage(HIBYTE(MEMMAP_START_ADDRESS));                  //Erase once and multiple writes  
  36   2           
  37   2          //RED_USER_DEFAULT TOKN VALUE---------------------------------
  38   2          IAP_WriteByte(RED_USER_START_ADRESS, 0);
  39   2          IAP_WriteByte(RED_USER_START_ADRESS+1,0);    
  40   2          IAP_WriteByte(RED_USER_START_ADRESS+2,0);
  41   2          IAP_WriteByte(RED_USER_START_ADRESS+3,0);
  42   2      
  43   2          //BLUE_USER_DEFAULT TOKN VALUE---------------------------------
  44   2          IAP_WriteByte(BLUE_USER_START_ADRESS, 0);
  45   2          IAP_WriteByte(BLUE_USER_START_ADRESS+1,0);     
  46   2          IAP_WriteByte(BLUE_USER_START_ADRESS+2,0);
  47   2          IAP_WriteByte(BLUE_USER_START_ADRESS+3,0);
  48   2           
  49   2           
  50   2          //GREEN_USER_DEFAULT TOKN VALUE---------------------------------
  51   2          IAP_WriteByte(GREEN_USER_START_ADRESS, 0);
  52   2          IAP_WriteByte(GREEN_USER_START_ADRESS+1,0);    
  53   2          IAP_WriteByte(GREEN_USER_START_ADRESS+2,0);
  54   2          IAP_WriteByte(GREEN_USER_START_ADRESS+3,0);
C51 COMPILER V9.60.0.0   MEMMAP                                                            10/30/2023 23:23:22 PAGE 2   

  55   2          
  56   2      
  57   2          //YELLOW_USER_DEFAULT TOKN VALUE---------------------------------
  58   2          IAP_WriteByte(YELLOW_USER_START_ADRESS, 0);
  59   2          IAP_WriteByte(YELLOW_USER_START_ADRESS+1,0);     
  60   2          IAP_WriteByte(YELLOW_USER_START_ADRESS+2,0);
  61   2          IAP_WriteByte(YELLOW_USER_START_ADRESS+3,0);
  62   2          
  63   2          IAP_WriteByte(BUZZER_SETTING_ADRESS,DEFAULT_BUZZER_ON_OR_OFF);
  64   2          
  65   2          IAP_WriteByte(MEMMAP_EEPROM_INIT_FLAG, EEPROM_INITIALIZED);       //set this byte to skip this Code on next
             - run
  66   2          
  67   2         }  
  68   1         
  69   1      }
  70          
  71          void SaveAllCrntSettings(void)
  72          {
  73   1        unsigned char xdata Data[17];
  74   1        Data[0]  =  Red[0];   Data[1]  = Red[1];   Data[2]  = Red[2];   Data[3]  = Red[3];
  75   1        Data[4]  =  Blue[0];  Data[5]  = Blue[1];  Data[6]  = Blue[2];  Data[7]  = Blue[3];
  76   1        Data[8]  =  Green[0]; Data[9]  = Green[1]; Data[10] = Green[2]; Data[11] = Green[3];
  77   1        Data[12] =  Yellow[0];Data[13] = Yellow[1];Data[14] = Yellow[2];Data[15] = Yellow[3];
  78   1        Data[17] =  1;
  79   1        EEPROM_Write_nByte(RED_USER_START_ADRESS,Data,16);
  80   1      }
  81          
  82          void LoadPreSettings(void)
  83          {
  84   1        unsigned char ElcCutFlg; 
  85   1        ElcCutFlg = EEPROM_Read_Byte((unsigned int) ELECTRICITY_CUT_FLG_ADRESS);
  86   1        if(ElcCutFlg == 1)
  87   1        {
  88   2          IAP_WriteByte(ELECTRICITY_CUT_FLG_ADRESS, 0);
  89   2          
  90   2          Red[0]   = EEPROM_Read_Byte((unsigned int)RED_USER_START_ADRESS);
  91   2          Red[1]   = EEPROM_Read_Byte((unsigned int)RED_USER_START_ADRESS+1);
  92   2          Red[2]   = EEPROM_Read_Byte((unsigned int)RED_USER_START_ADRESS+2);
  93   2          Red[3]   = EEPROM_Read_Byte((unsigned int)RED_USER_START_ADRESS+3);
  94   2              
  95   2          Blue[0]  = EEPROM_Read_Byte((unsigned int)BLUE_USER_START_ADRESS);
  96   2          Blue[1]  = EEPROM_Read_Byte((unsigned int)BLUE_USER_START_ADRESS+1);
  97   2          Blue[2]  = EEPROM_Read_Byte((unsigned int)BLUE_USER_START_ADRESS+2);
  98   2          Blue[3]  = EEPROM_Read_Byte((unsigned int)BLUE_USER_START_ADRESS+3);
  99   2          
 100   2          Green[0] = EEPROM_Read_Byte((unsigned int)GREEN_USER_START_ADRESS);
 101   2          Green[1] = EEPROM_Read_Byte((unsigned int)GREEN_USER_START_ADRESS+1);
 102   2          Green[2] = EEPROM_Read_Byte((unsigned int)GREEN_USER_START_ADRESS+2);
 103   2          Green[3] = EEPROM_Read_Byte((unsigned int)GREEN_USER_START_ADRESS+3);
 104   2            
 105   2          Yellow[0]= EEPROM_Read_Byte((unsigned int)YELLOW_USER_START_ADRESS);
 106   2          Yellow[1]= EEPROM_Read_Byte((unsigned int)YELLOW_USER_START_ADRESS+1);
 107   2          Yellow[2]= EEPROM_Read_Byte((unsigned int)YELLOW_USER_START_ADRESS+2);
 108   2          Yellow[3]= EEPROM_Read_Byte((unsigned int)YELLOW_USER_START_ADRESS+3);
 109   2       }
 110   1        
 111   1      
 112   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
C51 COMPILER V9.60.0.0   MEMMAP                                                            10/30/2023 23:23:22 PAGE 3   

   CODE SIZE        =    473    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----      17
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
